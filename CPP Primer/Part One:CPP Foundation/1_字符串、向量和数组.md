## 标准库类型`string`

标准库类型`string`表示可变长的字符序列。

**一、定义和初始化`string`对象**

常用的初始化方法：

```c++
string s1; //默认初始化，s1是一个空串
string s2(s1); //s2是s1的副本
string s2 = s1; //等价于s2(s1),s2是s1的副本
string s3("value"); //s3是字面值"value"的副本，除了字面值最后的那个空字符串外
string s3 = "value"; //等价于s3("value")，s3是字面值"value"的副本
string s4(n,'c'); //把s4初始化为由连续n个字符c组成的串
```

**直接初始化和拷贝初始化**

如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化**，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，则执行的是**直接初始化**。

初始值由多个时，一般用直接初始化。如`string s4(n,'c');`

但是拷贝初始化也可以，不过需要额外的创建一个（临时）对象用于拷贝：

```c++
string s5 = string(10,'c');
//等价于
string temp(10,'c'); //temp的内容是cccccccccc
string s5 = temp; //将temp的内容拷贝给s5
```

**二、`string`对象上的操作**

一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。

常用操作有:

```cpp                   
os<<s;	//将s写到输出流os中，返回os
is>>s;	//从is中读取字符串赋给s,字符串以空白分隔，返回is。
getline(is,s); //从is中读取一行赋给s，返回is
s.empty(); //s为空返回true,否则返回false
s.size(); //返回s中字符的个数
s[n]; //返回s中第n+1个字符的引用
s1+s2; //返回s1和s2连接后的结果
s1=s2; //用s2的副本替代s1中原来的字符
s1==s2; //如果s1和s2中所含的字符完全一样，则他们相等；string对象的相等性判断对字母的大小写敏感
s1!=s2;
<,<=,>,>=; //利用字符在字典中的顺序进行比较，且对字母的大小写敏感
```

**读写`string`对象**

利用标准库中的`iostream`来读写。`string`对象会自动忽略开头的空白，从第一个真正的字符开始读起，直到遇见下一处空白。

**使用`getline`读取一整行**

`getline(cin,string);`两个参数，一个输入流，一个想要读入输入流的字符串。

`getline`函数可以读入**空白符**，当遇到**换行符**时，会将字符串连带换行符一起读入，然后将抛弃掉换行符的内容输出到`string`字符串中。（如果一开始就遇到换行符，就会读入空字符串）

```c++
#include <iostream>

int main(void)
{
	string line;
    //每次读入一整行，直至到达文件末尾
    while(getline(cin,line)) {
        std::cout << line << std::endl; //line中并不包含换行符，所有我们要手动加入
    }
    return 0;
}
```

**`string::size_type`类型**

`size()`函数返回的类型其实是**`string::size_type`**类型的值。

该类型是一个无符号类型的值，而且足以存放下任何string对象的大小。，所用用于存放`string`类的`size`函数返回值的变量，都应该是`string::size_type`类型的。且在C++11中，允许用`auto`和`decltype`来推断。

## 基于范围的`for`语句

如果想对`string`对象中的每个字符做点什么操作，可以使用**范围for语句**。这种语句**遍历给定序列中的每个元素并对序列中的每个值执行某种操作**。其语法形式是：

```c++
for (declaration : expression)
	statement
```

其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。例如：

```c++
string str("Hello World!");
//每行输出str中的一个字符
for (auto c : str)
	printf("%c\n",c);
```

如果想要在遍历元素的过程中修改元素的值，就必须将变量定义成**引用**类型。反之，建议使用**`const &`**类型（避免了拷贝的同时也能避免修改原元素）。



## 标准库类型`vector`

标准库类型**`vector`**表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它也常被称作**容器**。vector是一个类模板。编译器根据模板创建类或函数的过程称为**实例化**。

当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

```c++
vector<int> ivec; //ivec存放保存int类型的对象
```

vector能容纳绝大部分类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用在内的vector。

**一、定义和初始化`vector`对象**

初始化的常用方法：

```c++
vector<T> v1; //v1是一个空vector，它潜在的元素是T类型的，执行默认初始化
vector<T> v2(v1); //v2中包含有v1所有元素的副本
vector<T> v2 = v1; //等价于v2(v1)，v2中包含有v1所有元素的副本
vector<T> v3(n,val); //v3包含类n个重复的元素，每个元素的值都是val
vector<T> v4(n); //v4包含了n个重复地执行了值初始化的对象
vector<T> v5(a,b,c...); //v5包含了初始值个数的元素，每个元素被赋予相应的初始值
vector<T> v5 = {a,b,c...}; //等价于v5(a,b,c...)
//创建指定数量的元素
vector<int> ivec(10,-1); //10个int类型的元素，每个都被初始化为-1
```

**列表初始化`vector`对象**

用花括号括起来的0个或多个初始元素值被赋给vector对象。

```c++
vector<string> articles = {"a","an","the"};
```

注意：使用拷贝初始化时，只能提供一个初始值；如果提供的是一个类内初始值（在类定义中为 `vector` 成员变量提供默认值），则只能使用拷贝初始化或使用花括号的形式初始化；如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里：

```c++
vector<stirng> v1{"a","an","the"}; //列表初始化
vector<string> v2("a","an","the"); //错误
```

详情见拓展1024。

**值初始化**

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值，此时库会创建一个**值初始化**元素初值，并把它赋给容器中的所有元素。这个初值有vector对象中元素的类型决定。

```c++
//如果vector对象的元素是内置类型，比如int，则元素初始值自动设为0,如果元素是某种类类型，比如string,则元素有类默认初始化：
vector<int> ivec(10); //10个元素，每个都初始化为0
vector<string> svec(10); //10个元素，每个都是空string对象
```

注意：要求提供初始值的地方（比如类内）不能使用；不能用拷贝初始化。

**列表初始化还是元素数量**

在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号，例如：

```c++
vector<int> v1(10); //v1有10个元素，每个的值都是0
vector<int> v2{10}; //v2有1个元素，值为10

vector<int> v3{10，1}; //v3有2个元素，值分别为10和1
vector<int> v4(10,1); //v4有10个元素，每个值都为1
```

如果列表初始化时提供的初始值与vector的要求不符，不是列表初始化。



**向`vector`对象中添加元素**

先创建一个空`vector`，然后在运行时再利用`vector`的成员函数**`push_back`**向其中添加元素。
push_back负责把一个值当成vector对象的尾元素“压到push_back”vector对象的“尾端”。

```c++ 
vecotr<int> v2; //空vecotr对象
for (int i = 0; i != 100; ++i) {
	v2.push_back(i); //依次把整数值放到v2尾端
	//循环结束后v2有100个元素，值从0到99
}
```

> **关键概念：<u>vector对象能高效增长</u>**
>
> C++标准要求vector应该能在运行时高效快速地添加元素。实际上，在定义vector对象时设定其大小可能使性能变得更差。所以一般在运行时加入元素。



**其他vector操作**

vector的大部分操作与string类似。

```c++
v.empty();
v.size();
v.push_back();
v[n];
v1 = v2;
v1 = {a,b,c,d...};
v1 == v2;
v1 != v2;
<,<=,>,>=;
```

> vector中的size_type类型是`vector<int>::size_type`类型。比如vector的下标类型，empty()函数的返回值。

注：不能以下标的形式向vector添加元素，但是可以进行访问操作。



## 迭代器

除了用下标运算符类访问string和vector对象的元素外，还有另外一种更通用的机制来实现相同的目的，即**迭代器**。

**使用迭代器**

有迭代器的类型同时拥有返回迭代器的成员。比如这些类型都拥有名为**begin()**和**end()**的成员 ，其中begin成员负责指向第一个元素的迭代器，而end成员负责返回迭代器**尾元素的下一个位置**。如果容器为空，那么两个成员指向的是同一个迭代器，都是尾后迭代器。

**迭代器运算符**

| 标准迭代器的运算符                     |                                                              |
| -------------------------------------- | ------------------------------------------------------------ |
| `*iter`                                | 返回迭代器`iter`所值元素的引用                               |
| `iter->mem`                            | 解引用`iter`并获取该元素的名为mem的成员，等价于(*`iter`).mem |
| `++iter`                               | 令`iter`指示容器中的下一个元素                               |
| `--iter`                               | 令`iter`指示容器中的上一个元素                               |
| `iter1 != iter2`<br />`iter1 != iter2` | 判断两个迭代器是否相等                                       |
|                                        |                                                              |

和指针类似，也必须通过解引用元素来获取它所指示的元素。

举个例子，下列程序利用迭代器把string对象的第一个字母改为了大写形式：

```cpp
string s("some string!");
if (s.begin() != s.end()) { //确保s非空
    auto it = s.begin(); //it表示s的第一个字符
    *it = toupper(*it); //将当前字符改成大写形式
}
```

><u>**关键概念：泛型编程**</u>
>
>C++语言习惯使用**`!=`**而非`<`进行判断，因为在迭代器中!=对所有容器都有效。

 **迭代器类型**

实际上，那些拥有迭代器的标准库类型使用`iterator`和`const_iterator`来表达迭代器类型：

```cpp
vector<int>::iterator it; //it能读写vector<int>的元素
string::iterator it2; //it2能读写string对象中的字符

vector<int>::const_iterator it3; //it3只能读元素，不能写元素
string::const_iterator it; //it4只能读字符，不能写字符
```

**`begin()`和`end()`运算符**

`begin()`和`end()`返回的具体类型有对象是否是常量决定，如果对象是常量，`begin()`和`end()`返回`const_iterator`；如果对象不是常量，返回`iterator`。

C++11标准引入了两个新函数：`cbegin()`和`cend()`。不管容器对象是否为常量，该迭代器都会返回`const_iterator`类型。

**结合解引用和成员访问操作**

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能进一步访问他的成员。

**某些对vector对象的操作会使迭代器失效**

1. 不能在范围for循环中向vector对象添加元素。
2. 任何一种改变vector对象容量的操作，比如`push_back`，都会使vector对象的迭代器失效。

## 数组

数组是一种类似于标准库类型vector的数据结构。数组的大小确定不变，不能随意的向数组中添加元素，因为数组的大小固定，依次对于某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。

**数组的声明**

```cpp
//数组是一种复合类型，数组的声明形如a[b],b必须是常量表达式
constexpr unsigned int sz = 42; //常量表达式
int arr[10]; //含有10个整数的数组
int *parr[sz]; //正确，含有42个整型指针的数组
```

> 默认情况下，数组的元素会被默认初始化。但是和内置类型一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

可以对数组进行**列表初始化**。

> 字符数组在使用字符进行列表初始化时，一定要在结尾处添加上`\0`作为字符串的结尾。
>
> `char s1 = {'c','a','o','\0;}`

**不允许拷贝和赋值**

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```c++
int a[] = {0,1,2}; //含有3个整数的数组
int a2[] = a; //错误：不允许使用一个数组初始化另一个数组
a2 = a; //错误：不能把一个数组直接赋值给另一个数组
```

**理解复杂的数组声明**

默认情况下，类型修饰符从右向左依次绑定。但是在某系情况下不太符合实际情况，所以一般要按照**从内向外**、**从右向左**的顺序读。

```c++
int (*Parry)[10] = &arr; //Parry指向一个含有10个整数的数组
int (&arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组
```

`Parray`的含义：首先是圆括号括起来的部分，`*Parray`意味着`Parray`是一个指针，接下来观察右边，可知道`Parray`是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是`int`。`Parray`是一个指针，它指向一个int数组，数组中包含一个10个元素。同理，`(&arrRef)`表示`arrRef`是一个引用，他引用的对象是一个大小为10的数组，数组中元素的类型是`int`。

**指针和数组**

通常情况下，使用**取地址符**来获取指向某个对象的指针，对数组使用下标运算符得到该数组指定位置的元素。对数组的元素使用取地址符就能得到指向该元素的指针。

```cpp
string nums["one","two","three"]; //数组的元素是string对象
string *p = &nums[0]; //p指向nums的第一个元素
```

编译器会将数字名替换为一个指向数组首元素的指针。

```cpp
string *p2 = nums; //等价于p2 = &nums[0]
```

在这种情况下，当使用数组作为一个`auto`变量的初始值时，推断得到的类型是指针而非数组。

```C++
int ia[] = {1,2,3,4,5,6,7,8,9}; //ia是一个含有10个整数的数组
auto ia2 = (ia); //ia2是一个整型指针，指向ia的第一个元素
ia2 = 42; //错误：ia2是一个指针，不能用int值给指针赋值
```

尽管`ia`是由10个整数构成的数组，但当使用`ia`作为初始值，编译器实际执行的初始值过程类似于下面的形式：

```cpp
auto ia2(&ia[0]); //显然ia2的类型是int*
```

但是使用**`deltype`**关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组：

``` c++
//ia3是一个含有10个整数的数组
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p; //错误：不能用整型指针给数组赋值
ia3[4] = i; //正确：把i的值赋给Ia3的一个元素
```



**数组的指针可以当数组的迭代器用,即可以执行所有迭代器的运算。**

两个指针相减的结果的类型是一种名为**`ptrdiff_t`**的标准库类型，和`size_t`一样，`ptrdiff_t`也是一种定义在`cstddef`头文件中的机器相关的类型。且因为差值可能为负值，所以`ptrdiff_t`是一种带符号类型。

**标准库函数begin()和end()**

为了让指针的使用更简单、更安全，C++11新标准引入了两个名为`begin`和`end`的标准库函数,这两个函数都定义在`iterator`头文件中。

```c++
int ia[] = {0,1,2,3,4,5,5,6,7,8,9}; //ia是一个含有10个整数的数值
int *beg = begin(ia); //指向ia首元素的指针
int *last = end(ia); //指向arr尾元素的下一位置的指针
```

使用`begin`和`end`可以很容易地写出一个循环并处理数组中的元素。例如，假设`arr`是一个整型数组， 下面的程序负责找到`arr`中的第一个负数：

```
//pbeg指向arr的首元素，pend指向arr尾元素的下一个位置
int *pbeg = begin(arr),*pend = end(arr);
//寻找第一个负值元素，如果已经检查完全部元素则结束循环
while (pbeg != pend && *pend >= 0) {
	++pbeg;
}
```

**下标和指针**

对数组执行下标运算其实是对指向数组元素的指针执行下标运算：

```c++
int i = ia[2]; //ia转换成指向数组首元素的指针
			  //ia[2]得到(ia + 2)所指的元素
int *p = ia;   //p指向ia的首元素
i = *(p + 2);  //等价于i = ia[2]
```

只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算符：

```c++
int *p = &ia[2]; //p指向索引为2的元素
int j = p[1]; //p[1]等价于*(p + 1),就是ia[3]表示的那个元素
int k = p[-2]; //p[-2]是ia[0]表示的那个元素
```

标准库类型（如`vector`、`string`）限定使用的下标必须是无符号类型，而内置的下标运算符无此要求（如上所示）。内置的下标运算符可以处理负值，当然，结果必须指向原来的指针所指同一数组中的元素。

## 多维数组

通常所说的多维数组其实是数组的数组。

当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示多维数组本身大小，另外一个维度表示其元素（也是数组）大小：

```c++
int ia[3][4]; //大小为3的数组，每个元素是含有4个整数的数组
//大小为10的数组，它的每个元素都是大小为20的数组
//这些数组的元素是含有30个整数的数组
int arr[10][20][30] = {0}; //将所有的元素初始化为0
```

按照**由内而外**的顺序阅读显然是一个正确的方法。从`ia[3]`到`ia[3][4]`再到`int ia[3][4]`。
对于二维数组来说，常把第一个维度称作行，第二个维度称作列。

**多维数组的初始化**

允许使用一组值初始化多维数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花落花括了起来：

```c++
int ia[3][4] = { //三个元素，每个元素都是大小为4的数组
	{0,1,2,3},	 //第1行的初始值
	{4,5,6,7},   //第2行的初始值
	{8,9,10,11}  //第3行的初始值
}
```

其中，内层嵌套着的花括号并非必须得，例如下面的初始化语句，形式上更为简洁，完成的功能和上面这段代码完全一样：

```c++
//没有标识符每行的花括号，与之前的初始化语句是等价的
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

类似于一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表之内。如果仅仅想初始化每一行的第一个元素，通过如下的语句即可：

```c++
//显式地初始化每行的首元素
int ia[3][4] = {{0},{4},{8}};
```

其他未列出的元素执行默认值初始化，这个过程和一维数组一样。在这种情况下如果在省略掉内层的花括号，结果就大不一样了。下面的代码含义发生了变化，它初始化的是第一行的4个元素，其他元素被初始化为0。

```c++
//显式地初始化第一行，其他元素执行值初始化
int ix[3][4] = {0,3,6,9};
```

**多维数组的下标引用**

```c++
int (&row)[4] = ia[1]; //把row绑定到ia的第二个4元素数组上
```

把`row`定义成一个含有4个整数的数组的引用，然后将其绑定到ia的第2行。

**指针和多维数组**

因为多维数组实际上是数组的数组，多以有多维数组名转换得来的指针实际上是指向第一个内层数组的指针：

```c++
int ia[3][4]; //大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia; //p指向含有4个整数的数组
p = &ia[2]; //p指向ia的元素
```

> 在上述声明中，圆括号必不可少：
>
> ```c++
> int *ip[4]; //整型指针的数组
> int (*ip)[4]; //指向含有4个整数的数组
> ```

二维数组的数组其实和一维数组一样，都是指向其数组的第一个元素，只不过二维数组的第一个元素是一个一维数组。也就是说如果对二维数组进行一次解引用，得到的是第一个一维数组的值（一维数组首元素的地址）。如果对其进行两次解引用操作，得到的是第一个一维数组首元素的值。

有一个二维数组`a[3][4]`，实际上`a`、`a[0]`、`&a[0][0]`的值是相同的，都是第一个一维数组首元素的地址，虽然得到的地址相同，但是它们的含义却不同，不要将它们搞混。因为如果对a（二维数组名）进行加一操作，会得到第二个一维数组的地址，如果对a[0]进行加一操作，得到的是第一个数组的第二个元素。编译器会对不同的名字进行区分，虽然实际地址都一样。

**对二维数组名进行不同的操作会产生不同的含义**

对二维数组名进行加一操作，含义为指向下一个一维数组；

对二维数组名进行解引用操作，含义为等价于一维数组名，指向一维数组的首元素。
