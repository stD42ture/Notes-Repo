## 基本内置类型

> 建议：如何选择类型
>
> - 当明确明确知晓数值不可能为负时，选用无符号类型。
> - 使用int进行整数运算。在算数表达式中尽量不要用char和bool。
> - 执行浮点运算选用double。实际上double的运行代价可能比float的代价还小。



## **自动类型转化**

需要注意的点：

1. 将一个非bool类型的算数值赋给bool类型时，初始值为0,则结果为false，否则结果为true。
2. 当我们赋给无符号类型一个超出它表示范围的值时（与带符号类型运算后产生错误的值），记过是初始值对无符号类型表示数值总数取模后的余数。
3. 给带符号类型一个超出它表示范围的值时，结果是**未定义**的。

> 建议：避免无法预知和依赖于实现环境的行为
>
> - 无法预知的行为源于编译器无需（有时是不能）检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍可能产生错误。
> - 程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作**不可移植的**。所以尽量选择通过类型。

注：切勿混用带符号类型和无符号类型。

字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符。所以字符串的实际长度要比它的内容多一。

## **变量**

变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算。

> 何为对象？
> 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。

## **初始化**

当对象在创建时获得了一个特定的值，就代表着这个对象被初始化了。

> WARNING:初始化不是赋值。初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新的值来替代。



位于函数体内部的内置类型变量将不被**默认初始化**。所以该变量是未定义的。所以不管是在任何地方的值，都建议进行初始化。



## **变量声明和定义的关系**

 C++语言支持**分离式编译**，该机制允许将程序分隔为若干个文件，每个文件可被独立编译。

为了支持分离式编译，C++语言将声明和定义区分开来。**声明**规定了变量的类型和名字，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而**定义**申请存储空间，也可能给变量赋一个初始值，负责创建于名字关联的实体。

`extern int i;` //声明i而非定义i

> Note：变量能且只能被定义一次，但是可以被多次声明。

> 如果函数有一个全局变量，也可以定义一个同名的局部变量（作用域内局部变量有效），但不建议这样做。



## **复合类型**

> 指基于其他类型定义的类型。包括引用和指针等。

一条声明语句有一个**基本数据类型**和其后的一个**声明符列表**组成（类型修饰符&、*是声明符的一部分）。

```cpp
int *p = nullptr; // int* p = nullptr 错误
```



引用详细介绍见_C++疑难点_。

**指针**是“指向”另外一种类型的复合类型。指针也实现了对其他对象的间接访问。

- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
- 指针无需在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。

指针利用**取地址符`&`**获取某个对象的地址，利用**解引用符**来访问该对象。

**指针值**

指针的值（即地址）应属于下列4种状态之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针也就是上述情况之外的其他值。

**空指针**

不指向任何对象。

```c++
int *p1 = nullptr; //等价于int *p1 = 0;
```

> 建议：初始化所有指针
>
> 使用未经初始化的指针是引发运行是错误的一大原因。

**void*指针**

是一种特殊的指针类型，可用于存放任意对象的地址。但是我们对该地址中到底是个什么类型的对象并不了解。

## `const`限定符

因为`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化。初始值可以是任意复杂的表达式。

```c++
const int i - get_size(); //正确：运行时初始化
const int j = 42; //正确：编译时初始化
const int k; //错误：k是一个未经初始化的常量。
```

`const`对象的常量特征仅仅在执行改变常量对象的操作是才会发挥作用。所以当使用const对象去初始化j时，根本无需在意const对象什么是一个常量。

**默认状态下，`const`对象仅在文件内有效**

当在编译时初始化一个常量时，如果程序包含多个文件，那么每个用了const对象的文件都必须能访问到它的初始值。那么就需要在每个文件内都进行定义，但为了避免重复定义，默认情况下，const对象被设定为仅在本文件内有效。

但如果存在一个运行时初始化的const对象，没办法在每个文件内都进行定义。可以在本文件内进行定义，其他文件进行声明，而不管是对于任何文件的定义还是声明都需要加上`**extern`关键字**，这样只需定义一次。

> Note：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。

**对`const`的引用**

可以把引用引用绑定到const对象上，就将绑定带其他对象上一样，我们称之为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象（意思是被引用的对象无法通过那个常量对象进行修改）。

```c++
const int ci = 1024;
const int &rl = ci; //正确：引用及其对应的对象都是常量
r1 = 42; //错误：r1是对常量的引用
int &r2 = ci; //错误：试图让一个非常量引用指向一个常量对象
```

**初始化和对`const`的引用**

通常情况下，引用的类型不许与其所引用对象的类型一致。但是有两个例外，第一种例外情况就是，在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。

```cpp
int i = 42;
const int &r1 = i; //允许将const int&绑定到一个普通int对象上
const int &r2 = 42; //正确：r2是一个常量引用。
const int &r3 = r1 * 2; //正确：r3是一个常量引用
int &r4 = r1 * 2; //错误：r4是一个普通的非常量引用
```

当对常量的引用绑定一个其表达式的结果可以转换成引用的类型的对象时，编译器会让被引用的对象赋值给一个生成的`const`**临时量**对象（编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象），该临时量对象的类型与对常量的引用一致。 赋值过程中会发生自动类型转换。然后将该临时量对象的值赋值给对常量的引用。

> 虽然实际上一个普通引用绑定的是临时量对象，但是程序员肯定想通过引用来改变被引用对象的值，所以没有人会想将引用绑定到临时量上，C++语言也将这种行为列为非法。

> 如果有一个非常量对象，同时被一个普通对象和一个常量对象引用。则不允许通过常量对象修改源对象的值，但允许通过普通对象修改。

**指针和`const`**

见_C++疑难_

 **顶层`const`**

**顶层`const`**表示指针本身是个常量。**底层`const`**指针所指的对象是一个常量。

当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层的`const`资格。或者两个对象的数据类型必须能够相互转换。一般来说，非常量可以转换成常量。反之则不行。

**`constexpr`和常量表达式**

**常量表达式**是指值不会改变并且在编译过程就能计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的`const`对象也是常量表达式。

**一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定**。

```c++
int staff_size = 27; //staff_size不是常量表达式
const int sz = get_size(); //sz不是常量表达式
```

尽管staff_size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而非const int，所以它不属于常量表达式。另一方面，尽管`sz`本身是一个常量，但它的具体值知道运行时擦能获取到，所以也不是常量表达式。

**`constexpr`变量**

在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式。C++11新标准规定，允许将变量声明为`constexpr`的变量类型以便由编译器来验证变量的值是否是一个常量表达式。声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化：

```C++
constexpr int mf = 20; //20是常量表达式
constexpr int limit = mf + 1; //mf + 1是常量表达式
constexpr int sz = size(); //只有当size是一个constexpr函数时，才是一条正确的声明语句
```

尽管不能使用普通函数作为`constexpr`变量的初始值，但是新标准允许定义一种特殊的`constexpr`函数。这种函数应该足够简单以使得编译的时候就可以计算结果，这样就能用`constexpr`函数去初始化`constexpr`变量了。

> 一般来说，如果你认定变量是一个常量表达式，那就把它声明为`constexpr`类型。

**字面值类型**

常量表达式的值需要在**编译是就得到计算**，因此对声明`constexpr`时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把他们称为“字面值类型”。**算数类型（整型和浮点型）、指针和引用都属于字面值类型**。

虽然指针和引用类型都能定义成`constexpr`,但他们的初始值却收到严格限制。一个`constexpr`指针的初始值必须是`nullptr`或者0,或者是存储于某个固定地址中的对象。

函数体内定义的变量一般来说并非存放在固定地址中，因此`constexpr`指针不能指向这样的变量。相反的，定义域所有的函数体之外的对象其地址固定不变，能用来初始化`constexpr`指针。而且允许函数定义一类有效范围超出函数本身的变量。这类变量和定义在函数体之外的变量一样也有固定地址。因此，`constexpr`引用能绑定到这样的变量上，`constexpr`指针也能指向这样的变量。

如果`constexpr`声明中如果定义了一个指针，那么该指针会被定义为**顶层const**对象（即指针是常量）。和其他常量指针一样，`constexpr`指针即可以指向常量也可以指向非常量。

## 处理类型

**类型别名**

> **Question**
>
> 类型别名的作用是什么？语法是什么样子的。

类型别名是某种类型名的同义词。

```c++
typedef double wages; //wages是double的同义词
typedef wages base,*p; //base是double的同义词，p是double* 的同义词。

using s = string; //s是string的别名
```

**在指针和常量上的注意点**

```c++
typedef char *pstring;
const pstring cstr = 0; //cstr是指向char类型的常量指针
const char *cstr_ = 0; //cstr_是指向常量char类型的指针
```

当遇到一条使用了类型别名的声明语句时，人们往往会错误的尝试把类型别名替换成它本来的样子。这种理解是错误的。`pstring`的基本数据类型是指针，而不是char，因为在声明别名的过程中，*成了声明符的一部分。

**auto类型说明符**

> **Question**
>
> auto的作用是什么？有什么前提条件。

`auto`可以让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型。显然auto定义的变量必须要有初始值。

**auto与常量**

1. 使用引用实际上是使用引用的对象。特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：

   ```c++
   int i = 0,&r = i;
   auto a = r; //a是一个整数（r是i的别名，而i是一个整数） 
   ```

2. auto一般会忽略掉顶层const，同时底层const会保留下来，比如当初始值是一个指向常量的指针时：

   ```c++
   const int ci = i;
   const int &cr = ci;
   auto b = ci; //b是一个整数（ci的顶层const特性被忽略掉了）
   auto c = cr; //c是一个整数（cr是ci的别名，ci本身是一个顶层const）
   auto d = &i; //d是一个整型指针（整数的地址就是指向整数的指针）
   auto e = &ci; //e是一个指向整数常量的指针（对常量对象去地址是一种底层const)
   //如果希望推断出的auto类型是一个顶层const，需要明确指出：
   const auto f = ci; //ci的推演类型是int，f是const int
   //还可以将引用的类型改为auto，此时原来的初始化规则仍然适用
   auto &g = ci; //g是一个整型常量引用，绑定ci--设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留--
   auto &h = 42; //错误：不能为非常量引用绑定字面值
   const auto &j = 42; //正确：可以为常量引用绑定字面值
   ```

   ```cpp
   #include <iostream>
   
   int main(void)
   {
       int i = 0;
       const int cr = 0;
       const int &ci = cr;
       auto b = cr; //b是一个整数（ci的顶层const特性被忽略掉了）
       std::cout << b << std::endl;
       b = 1;
       std::cout << b << std::endl;
       return 0;
   }
   ```

   注：符号&和*从来只属于某个声明符，而不属于某个基本数据类型。

**`decltype`类型指示符**

> **`Qusetion`**
> `decltype`类型指示符的作用是什么？

`decltype`的作用是<u>选择并返回操作数的数据类型</u>。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：

```c++
decltype(fun()) i = x;	//i的类型就是fun()返回的类型
```

编译器并不实际调用函数fun()，而是使用当调用发生时f的返回值类型作为i的类型（假设fun()调用时）。

`decltype`处理顶层const和引用的方式与auto有些不同。如果`decltype`使用的表达式是一个变量，则`decltype`返回该变量的类型（包括顶层const和引用在内）：

```c++
const int ci = 0,&cj = ci;
decltype(ci) x = 0; //x的类型是const int
decltype(cj) y = x; //y的类型是const int&,y绑定到变量x
decltype(cj) z; //错误：z是一个引用必须初始化
```

**`decltype`和引用**

如果`decltype`使用的表达式不是一个变量，则`decltype`<u>返回表达式结果对应的类型</u>。有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一个赋值语句的左值：

```c++
//decltype的结果可以是引用类型
int i = 42,*p = &i,&r = i;
decltype(r + 0) b; //正确：加法的结果是int，因此b是一个（未初始化的）int
decltype(*p) c; //错误：c是int&，必须初始化
```

因为r是一个引用，因此`decltype(r)`的结果是引用类型，则decltype将得到引用类型。正如我们所熟悉的那样，可以把r作为表达式的一部分，如r + 0，显然这个表达式的结果将是一个具体而非一个引用。

另一方面，如果表达式的内容是解引用操作，则`decltype`将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因为，`decltype`(*p)的结果类型就是int&,而非int。

如果`decltype`使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型。

```c++
//decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d; //错误：d是int&,必须初始化
decltype(i) e; //正确：e是一个（未初始化）int
```

> 切记：`decltype`((variable))（注意是双层括号）结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。 
